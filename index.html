<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Golf Maze Course</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
<style>
  body { margin:0; overflow:hidden; font-family:sans-serif; }
  #hud {
    position: absolute;
    top: 10px;
    left: 10px;
    color: white;
    z-index: 100;
    background: rgba(0,0,0,0.4);
    padding: 10px;
    border-radius: 8px;
  }
  #winMessage {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: gold;
    font-size: 48px;
    display: none;
    z-index: 101;
    text-shadow: 2px 2px 5px #000;
  }
</style>
</head>
<body>
<div id="hud">
  <div id="strokes">Strokes: 0</div>
  <div>Par: 9</div>
  <div>Controls: Q/E aim, Space putt, WASD move camera</div>
</div>
<div id="winMessage">You Won!</div>

<a-scene>

  <!-- Sky and ground -->
  <a-sky color="#87CEEB"></a-sky>
  <a-plane color="#2d5016" rotation="-90 0 0" width="500" height="500"></a-plane>

  <!-- Ball -->
  <a-sphere id="ball" position="0 0.5 0" radius="0.2" color="#ffffff"></a-sphere>

  <!-- Camera -->
  <a-entity id="cameraRig" position="0 3 6">
    <a-camera id="camera"></a-camera>
  </a-entity>

  <!-- Aim arrow -->
  <a-entity id="aimArrow" line="start: 0 0.5 0; end: 0 0.5 -2; color: red"></a-entity>

</a-scene>

<script>
const scene = document.querySelector('a-scene');
const fairwayWidth = 5;
const wallColliders = [];
const obstacles = [];
const ballEl = document.querySelector('#ball');
const strokesEl = document.querySelector('#strokes');
const winEl = document.querySelector('#winMessage');

let strokes = 0;
let ballVel = {x:0,z:0};
let aimAngle = 0;

function createSegment(start, end, extensions = {}) {
  const dx = end.x - start.x;
  const dz = end.z - start.z;
  const length = Math.sqrt(dx*dx + dz*dz);
  const angle = Math.atan2(dx, dz);
  const angleDeg = angle * (180/Math.PI);
  const midX = (start.x + end.x)/2;
  const midZ = (start.z + end.z)/2;

  // Fairway
  const fairway = document.createElement('a-box');
  fairway.setAttribute('position', `${midX} 0.01 ${midZ}`);
  fairway.setAttribute('width', fairwayWidth);
  fairway.setAttribute('height', 0.02);
  fairway.setAttribute('depth', length);
  fairway.setAttribute('rotation', `0 ${angleDeg} 0`);
  fairway.setAttribute('color', '#3a7d44');
  scene.appendChild(fairway);

  const dirX = dx / length;
  const dirZ = dz / length;
  const perpX = -dirZ;
  const perpZ = dirX;

  // Left wall
  const leftStartOffset = extensions.leftStart || 0;
  const leftEndOffset = extensions.leftEnd || 0;
  const leftStartX = start.x + perpX*(fairwayWidth/2) - dirX*leftStartOffset;
  const leftStartZ = start.z + perpZ*(fairwayWidth/2) - dirZ*leftStartOffset;
  const leftEndX = end.x + perpX*(fairwayWidth/2) + dirX*leftEndOffset;
  const leftEndZ = end.z + perpZ*(fairwayWidth/2) + dirZ*leftEndOffset;
  const leftMidX = (leftStartX + leftEndX)/2;
  const leftMidZ = (leftStartZ + leftEndZ)/2;
  const leftLength = Math.sqrt((leftEndX-leftStartX)**2 + (leftEndZ-leftStartZ)**2);

  const leftWall = document.createElement('a-box');
  leftWall.setAttribute('position', `${leftMidX} 0.5 ${leftMidZ}`);
  leftWall.setAttribute('width', 0.2);
  leftWall.setAttribute('height', 1);
  leftWall.setAttribute('depth', leftLength);
  leftWall.setAttribute('rotation', `0 ${angleDeg} 0`);
  leftWall.setAttribute('color', '#8B5A2B');
  scene.appendChild(leftWall);
  wallColliders.push({x1:leftStartX, z1:leftStartZ, x2:leftEndX, z2:leftEndZ});

  // Right wall
  const rightStartOffset = extensions.rightStart || 0;
  const rightEndOffset = extensions.rightEnd || 0;
  const rightStartX = start.x - perpX*(fairwayWidth/2) - dirX*rightStartOffset;
  const rightStartZ = start.z - perpZ*(fairwayWidth/2) - dirZ*rightStartOffset;
  const rightEndX = end.x - perpX*(fairwayWidth/2) + dirX*rightEndOffset;
  const rightEndZ = end.z - perpZ*(fairwayWidth/2) + dirZ*rightEndOffset;
  const rightMidX = (rightStartX + rightEndX)/2;
  const rightMidZ = (rightStartZ + rightEndZ)/2;
  const rightLength = Math.sqrt((rightEndX-rightStartX)**2 + (rightEndZ-rightStartZ)**2);

  const rightWall = document.createElement('a-box');
  rightWall.setAttribute('position', `${rightMidX} 0.5 ${rightMidZ}`);
  rightWall.setAttribute('width', 0.2);
  rightWall.setAttribute('height', 1);
  rightWall.setAttribute('depth', rightLength);
  rightWall.setAttribute('rotation', `0 ${angleDeg} 0`);
  rightWall.setAttribute('color', '#8B5A2B');
  scene.appendChild(rightWall);
  wallColliders.push({x1:rightStartX, z1:rightStartZ, x2:rightEndX, z2:rightEndZ});
}

// The horrendus array.
const path = [
  {x:0, z:0},
  {x:0, z:-20},
  {x:15, z:-40},
  {x:5, z:-60},
  {x:-5, z:-80},
  {x:10, z:-100},
  {x:8, z:-120}
];

// Slight adjustments because path's dont connect fully
createSegment(path[0], path[1], { leftStart:.5, leftEnd:-0.8, rightStart:.5, rightEnd:0.9 });
createSegment(path[1], path[2], { leftStart:-0.7, leftEnd:1.5, rightStart:0.8, rightEnd:-1.5 });
createSegment(path[2], path[3], { leftStart:1.5, leftEnd:0.3, rightStart:-1.5, rightEnd:0.4 });
createSegment(path[3], path[4], { leftStart:0.3, leftEnd:-1.5, rightStart:0.4, rightEnd:1.5 });
createSegment(path[4], path[5], { leftStart:-1.5, leftEnd:1, rightStart:1.6, rightEnd:-.9 });
createSegment(path[5], path[6], { leftStart:1, leftEnd:0.7, rightStart:-1, rightEnd:0.8 });

// Start wall, doesn't work with array function
(function(){
  const start = path[0];
  const offsetZ = .5;
  const midX = start.x;
  const midZ = start.z + offsetZ;
  const startWall = document.createElement('a-box');
  startWall.setAttribute('position', `${midX} 0.5 ${midZ}`);
  startWall.setAttribute('width', fairwayWidth);
  startWall.setAttribute('height', 1);
  startWall.setAttribute('depth', 0.2);
  startWall.setAttribute('color', '#8B5A2B');
  scene.appendChild(startWall);
  wallColliders.push({x1: midX - fairwayWidth/2, z1: midZ, x2: midX + fairwayWidth/2, z2: midZ});
})();

// End wall, doesn't work with array function
(function(){
  const end = path[path.length-1];
  const offsetZ = -0.6;
  const midX = end.x;
  const midZ = end.z + offsetZ;
  const endWall = document.createElement('a-box');
  endWall.setAttribute('position', `${midX} 0.5 ${midZ}`);
  endWall.setAttribute('width', fairwayWidth);
  endWall.setAttribute('height', 1);
  endWall.setAttribute('depth', 0.2);
  endWall.setAttribute('color', '#8B5A2B');
  scene.appendChild(endWall);
  wallColliders.push({x1: midX - fairwayWidth/2, z1: midZ, x2: midX + fairwayWidth/2, z2: midZ});
})();

// Obstacles for extra credit, teehee
function createObstacle(x,z,w=1,d=2){
  const ob = document.createElement('a-box');
  ob.setAttribute('position',`${x} 0.2 ${z}`);
  ob.setAttribute('width',w);
  ob.setAttribute('height',0.5);
  ob.setAttribute('depth',d);
  ob.setAttribute('color','#d62828');
  scene.appendChild(ob);
  obstacles.push({x:x,z:z,w:w,d:d});
}
createObstacle(0,-10,1,2);
createObstacle(9,-30,1.5,1.5);
createObstacle(9,-50,1,2);
createObstacle(0,-70,1.5,1);
createObstacle(-1,-88,1,2);
createObstacle(8,-105,1.5,1.5);
createObstacle(9,-118,1,2);

//This is for the hole
const holeObj = document.createElement('a-cylinder');
holeObj.setAttribute('position',`${path[path.length-1].x} 0 ${path[path.length-1].z}`);
holeObj.setAttribute('radius',0.3);
holeObj.setAttribute('height',0.1);
holeObj.setAttribute('color','#000');
scene.appendChild(holeObj);

const holeFlagPole = document.createElement('a-cylinder');
holeFlagPole.setAttribute('position',`${path[path.length-1].x} 0.8 ${path[path.length-1].z}`);
holeFlagPole.setAttribute('radius',0.03);
holeFlagPole.setAttribute('height',1.6);
holeFlagPole.setAttribute('color','#fff');
scene.appendChild(holeFlagPole);

const holeFlag = document.createElement('a-box');
holeFlag.setAttribute('position',`${path[path.length-1].x} 1.5 ${path[path.length-1].z}`);
holeFlag.setAttribute('width',0.5);
holeFlag.setAttribute('height',0.3);
holeFlag.setAttribute('depth',0.02);
holeFlag.setAttribute('color','#f00');
scene.appendChild(holeFlag);

// How the camera moves with the ball, I felt this was really important
const cameraRig = document.querySelector('#cameraRig');
const camera = document.querySelector('#camera');
let orbitX=0,orbitZ=6,orbitHeight=3;
const keys={};
window.addEventListener('keydown', e=>keys[e.code]=true);
window.addEventListener('keyup', e=>keys[e.code]=false);

//How the ball moves with the keyboard
window.addEventListener('keydown', e=>{
  if(e.code==='KeyQ') aimAngle-=0.05;
  if(e.code==='KeyE') aimAngle+=0.05;
  if(e.code==='Space'){
    const power=0.5;
    ballVel.x=Math.sin(aimAngle)*power;
    ballVel.z=-Math.cos(aimAngle)*power;
    strokes++;
    strokesEl.innerText = `Strokes: ${strokes}`;
  }
});

// Wanted camera to move like original THREE.js but I wanted to lock the height and make it follow the ball
//If you're playing, you'll find out when you turn, W still moves you north, S for south, etc.
//no mater what way you're facing. No, I don't know how to fix it.
function updateCamera(){
  const pos = ballEl.getAttribute('position');
  if(keys['KeyW']) orbitZ-=0.5;
  if(keys['KeyS']) orbitZ+=0.5;
  if(keys['KeyA']) orbitX-=0.5;
  if(keys['KeyD']) orbitX+=0.5;

  cameraRig.setAttribute('position',{x:pos.x+orbitX,y:pos.y+orbitHeight,z:pos.z+orbitZ});
  camera.object3D.lookAt(new THREE.Vector3(pos.x,pos.y+0.5,pos.z));
  requestAnimationFrame(updateCamera);
}
updateCamera();

// I have no idea what this is, GPT help
function closestPointOnSegment(px, pz, x1, z1, x2, z2) {
  const dx = x2 - x1;
  const dz = z2 - z1;
  const lenSq = dx*dx + dz*dz;
  if(lenSq===0) return {x:x1,z:z1};
  let t = ((px - x1)*dx + (pz - z1)*dz)/lenSq;
  t = Math.max(0, Math.min(1,t));
  return {x: x1 + t*dx, z: z1 + t*dz};
}

// Updating the ball position, also works for checking position with walls and hole for "collision"
function updateBall(){
  const pos = ballEl.getAttribute('position');
  pos.x += ballVel.x;
  pos.z += ballVel.z;
  pos.y = 0.5;
  const ballRadius = 0.2;
  const wallThickness = 0.1;

  // Wall collisions, self explanatory
  for(let wall of wallColliders){
    const closest = closestPointOnSegment(pos.x,pos.z,wall.x1,wall.z1,wall.x2,wall.z2);
    const dx = pos.x - closest.x;
    const dz = pos.z - closest.z;
    const dist = Math.sqrt(dx*dx + dz*dz);
    if(dist < ballRadius + wallThickness){
      const nx = dx / dist;
      const nz = dz / dist;
      const dot = ballVel.x*nx + ballVel.z*nz;
      if(dot < 0){
        ballVel.x -= 2*dot*nx;
        ballVel.z -= 2*dot*nz;
        ballVel.x *= 0.75;
        ballVel.z *= 0.75;
        const overlap = (ballRadius + wallThickness)-dist;
        pos.x += nx*overlap;
        pos.z += nz*overlap;
      }
    }
  }

//Making obstacles for extra credit teehee
  for(let o of obstacles){
    const dx = pos.x - o.x;
    const dz = pos.z - o.z;
    const clampedX = Math.max(-o.w/2, Math.min(o.w/2, dx));
    const clampedZ = Math.max(-o.d/2, Math.min(o.d/2, dz));
    const closestX = o.x + clampedX;
    const closestZ = o.z + clampedZ;
    const distX = pos.x - closestX;
    const distZ = pos.z - closestZ;
    const dist = Math.sqrt(distX*distX + distZ*distZ);
    if(dist < ballRadius){
      const nx = distX/dist;
      const nz = distZ/dist;
      const dot = ballVel.x*nx + ballVel.z*nz;
      if(dot < 0){
        ballVel.x -= 2*dot*nx;
        ballVel.z -= 2*dot*nz;
        ballVel.x *= 0.75;
        ballVel.z *= 0.75;
        const overlap = ballRadius - dist;
        pos.x += nx*overlap;
        pos.z += nz*overlap;
      }
    }
  }
//"Friction" for the homemade physics engine, basically I need the ball to slow down
  ballVel.x *= 0.97;
  ballVel.z *= 0.97;
  if(Math.abs(ballVel.x)<0.001) ballVel.x=0;
  if(Math.abs(ballVel.z)<0.001) ballVel.z=0;

  // Checking the ball for win loaction at each frame using requestAnimationFrame
  const holePos = path[path.length-1];
  const dx = pos.x - holePos.x;
  const dz = pos.z - holePos.z;
  if(Math.sqrt(dx*dx + dz*dz) < 0.3 && ballVel.x===0 && ballVel.z===0){
    winEl.style.display = 'block';
    setTimeout(()=>{
      winEl.style.display='none';
      ballEl.setAttribute('position',{x:path[0].x, y:0.5, z:path[0].z});
      ballVel.x=0;
      ballVel.z=0;
      strokes = 0;
      strokesEl.innerText = `Strokes: ${strokes}`;
    },2000);
  }

  ballEl.setAttribute('position',pos);
  requestAnimationFrame(updateBall);
}
updateBall();

//This portion is for knowing where you're aiming
//Drag didn't work so I decided we'll aim with our keyboard, needed a visual.
const aimArrow = document.querySelector('#aimArrow');
function updateAimArrow(){
  const pos = ballEl.getAttribute('position');
  const endX = pos.x + Math.sin(aimAngle)*2;
  const endZ = pos.z - Math.cos(aimAngle)*2;
  aimArrow.setAttribute('line',`start: ${pos.x} 0.5 ${pos.z}; end: ${endX} 0.5 ${endZ}; color: red`);
  requestAnimationFrame(updateAimArrow);
}
updateAimArrow();
</script>
</body>
</html>
