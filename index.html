<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Golf Maze Course</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
</head>
<body>
<a-scene>

  <!-- Sky and ground -->
  <a-sky color="#87CEEB"></a-sky>
  <a-plane color="#2d5016" rotation="-90 0 0" width="500" height="500"></a-plane>

  <!-- Ball -->
  <a-sphere id="ball" position="0 0.5 0" radius="0.2" color="#ffffff"></a-sphere>

  <!-- Camera -->
  <a-entity id="cameraRig" position="0 3 6">
    <a-camera id="camera"></a-camera>
  </a-entity>

  <!-- Aim arrow -->
  <a-entity id="aimArrow" line="start: 0 0.5 0; end: 0 0.5 -2; color: red"></a-entity>

</a-scene>

<script>
const scene = document.querySelector('a-scene');

// ---- Define the path as points - MORE CREATIVE LAYOUT ----
const path = [
  {x:0, z:0},
  {x:0, z:-20},      // straight
  {x:15, z:-40},     // diagonal right
  {x:5, z:-60},      // sharp left
  {x:5, z:-80},      // straight narrow
  {x:-10, z:-95},    // hard left turn
  {x:10, z:-115},    // S-curve right
  {x:8, z:-140},     // slight left
  {x:8, z:-160}      // final straight to hole
];

const fairwayWidth = 4;

// Helper to create a fairway segment and walls
function createSegment(start, end) {
  const dx = end.x - start.x;
  const dz = end.z - start.z;
  const length = Math.sqrt(dx*dx + dz*dz);
  const angle = Math.atan2(dx, dz) * (180/Math.PI);

  // Fairway
  const fairway = document.createElement('a-box');
  fairway.setAttribute('position', {x:(start.x+end.x)/2, y:0.01, z:(start.z+end.z)/2});
  fairway.setAttribute('width', fairwayWidth);
  fairway.setAttribute('height', 0.02);
  fairway.setAttribute('depth', length);
  fairway.setAttribute('rotation', `0 ${angle} 0`);
  fairway.setAttribute('color', '#3a7d44');
  scene.appendChild(fairway);

  // Calculate perpendicular direction for wall placement
  const angleRad = angle * Math.PI / 180;
  const perpX = -Math.sin(angleRad);
  const perpZ = Math.cos(angleRad);

  // Walls - properly positioned perpendicular to the segment
  const midX = (start.x + end.x) / 2;
  const midZ = (start.z + end.z) / 2;

  const leftWall = document.createElement('a-box');
  leftWall.setAttribute('position', {
    x: midX + perpX * (fairwayWidth/2), 
    y: 0.5, 
    z: midZ + perpZ * (fairwayWidth/2)
  });
  leftWall.setAttribute('width', 0.2);
  leftWall.setAttribute('height', 1);
  leftWall.setAttribute('depth', length);
  leftWall.setAttribute('rotation', `0 ${angle} 0`);
  leftWall.setAttribute('color', '#5c4033');
  scene.appendChild(leftWall);

  const rightWall = document.createElement('a-box');
  rightWall.setAttribute('position', {
    x: midX - perpX * (fairwayWidth/2), 
    y: 0.5, 
    z: midZ - perpZ * (fairwayWidth/2)
  });
  rightWall.setAttribute('width', 0.2);
  rightWall.setAttribute('height', 1);
  rightWall.setAttribute('depth', length);
  rightWall.setAttribute('rotation', `0 ${angle} 0`);
  rightWall.setAttribute('color', '#5c4033');
  scene.appendChild(rightWall);

  return {
    start, end, angle: angleRad, length,
    leftWall: {el: leftWall, x: midX + perpX * (fairwayWidth/2), z: midZ + perpZ * (fairwayWidth/2), normalX: perpX, normalZ: perpZ},
    rightWall: {el: rightWall, x: midX - perpX * (fairwayWidth/2), z: midZ - perpZ * (fairwayWidth/2), normalX: -perpX, normalZ: -perpZ}
  };
}

// Build the course
const segments = [];
for(let i=0;i<path.length-1;i++){
  segments.push(createSegment(path[i], path[i+1]));
}

// ---- Obstacles ----
const obstacles = [];
function createObstacle(x,z,w=1,d=2){
  const ob = document.createElement('a-box');
  ob.setAttribute('position',{x:x,y:0.2,z:z});
  ob.setAttribute('width',w);
  ob.setAttribute('height',0.5);
  ob.setAttribute('depth',d);
  ob.setAttribute('color','#d62828');
  scene.appendChild(ob);
  obstacles.push({x:x,z:z,w:w,d:d});
}
createObstacle(0,-10,1,2);
createObstacle(10,-30,1.5,1.5);
createObstacle(7,-50,1,2);
createObstacle(5,-70,1.5,1);
createObstacle(-5,-88,1,2);
createObstacle(5,-105,1.5,1.5);
createObstacle(8,-130,1,2);

// ---- Hole ----
const hole = document.createElement('a-cylinder');
hole.setAttribute('position',{x:path[path.length-1].x,y:0,z:path[path.length-1].z});
hole.setAttribute('radius',0.3);
hole.setAttribute('height',0.1);
hole.setAttribute('color','#000');
scene.appendChild(hole);

const holeFlagPole = document.createElement('a-cylinder');
holeFlagPole.setAttribute('position',{x:path[path.length-1].x,y:0.8,z:path[path.length-1].z});
holeFlagPole.setAttribute('radius',0.03);
holeFlagPole.setAttribute('height',1.6);
holeFlagPole.setAttribute('color','#fff');
scene.appendChild(holeFlagPole);

const holeFlag = document.createElement('a-box');
holeFlag.setAttribute('position',{x:path[path.length-1].x,y:1.5,z:path[path.length-1].z});
holeFlag.setAttribute('width',0.5);
holeFlag.setAttribute('height',0.3);
holeFlag.setAttribute('depth',0.02);
holeFlag.setAttribute('color','#f00');
scene.appendChild(holeFlag);

// ---- Ball physics ----
const ballEl = document.querySelector('#ball');
let ballVel = {x:0,z:0};
let aimAngle = 0;

// Camera WASD
const cameraRig = document.querySelector('#cameraRig');
const camera = document.querySelector('#camera');
let orbitX=0,orbitZ=6,orbitHeight=3;
const keys={};
window.addEventListener('keydown', e=>keys[e.code]=true);
window.addEventListener('keyup', e=>keys[e.code]=false);

// Q/E aim, Space putt
window.addEventListener('keydown', e=>{
  if(e.code==='KeyQ') aimAngle-=0.05;
  if(e.code==='KeyE') aimAngle+=0.05;
  if(e.code==='Space'){
    const power=0.5;
    ballVel.x=Math.sin(aimAngle)*power;
    ballVel.z=-Math.cos(aimAngle)*power;
  }
});

// Camera
function updateCamera(){
  const pos = ballEl.getAttribute('position');
  if(keys['KeyW']) orbitZ-=0.5;
  if(keys['KeyS']) orbitZ+=0.5;
  if(keys['KeyA']) orbitX-=0.5;
  if(keys['KeyD']) orbitX+=0.5;

  cameraRig.setAttribute('position',{x:pos.x+orbitX,y:pos.y+orbitHeight,z:pos.z+orbitZ});
  camera.object3D.lookAt(new THREE.Vector3(pos.x,pos.y+0.5,pos.z));
  requestAnimationFrame(updateCamera);
}
updateCamera();

// ---- Vector helper ----
function reflectVelocity(vel, normal){
  const dot = vel.x*normal.x + vel.z*normal.z;
  return {
    x: vel.x - 2*dot*normal.x,
    z: vel.z - 2*dot*normal.z
  };
}

// Ball movement with FIXED bouncing physics
function updateBall(){
  const pos = ballEl.getAttribute('position');
  pos.x += ballVel.x;
  pos.z += ballVel.z;
  pos.y = 0.5;

  const damping = 0.75;

  // Check walls - PROPERLY NOW
  for(let seg of segments){
    const walls = [seg.leftWall, seg.rightWall];
    for(let wall of walls){
      const cos = Math.cos(seg.angle);
      const sin = Math.sin(seg.angle);
      const halfW = 0.2/2 + 0.2;
      const halfD = seg.length/2 + 0.2;

      // Transform ball pos to wall local space
      const localX = cos*(pos.x - wall.x) + sin*(pos.z - wall.z);
      const localZ = -sin*(pos.x - wall.x) + cos*(pos.z - wall.z);

      if(Math.abs(localX)<halfW && Math.abs(localZ)<halfD){
        // Use the pre-calculated normal from wall data
        const normal = {x: wall.normalX, z: wall.normalZ};
        const newVel = reflectVelocity(ballVel, normal);
        ballVel.x = newVel.x*damping;
        ballVel.z = newVel.z*damping;
        
        // Push ball away from wall to prevent sticking
        pos.x += wall.normalX * 0.15;
        pos.z += wall.normalZ * 0.15;
      }
    }
  }

  // Check obstacles
  for(let o of obstacles){
    if(Math.abs(pos.x-o.x)<o.w/2+0.2 && Math.abs(pos.z-o.z)<o.d/2+0.2){
      const dx = pos.x - o.x;
      const dz = pos.z - o.z;
      const normal = Math.abs(dx) > Math.abs(dz) ? {x: Math.sign(dx), z:0} : {x:0,z:Math.sign(dz)};
      const newVel = reflectVelocity(ballVel, normal);
      ballVel.x = newVel.x*damping;
      ballVel.z = newVel.z*damping;
      
      // Push ball away from obstacle
      pos.x += normal.x * 0.15;
      pos.z += normal.z * 0.15;
    }
  }

  // Friction
  ballVel.x *= 0.97;
  ballVel.z *= 0.97;
  if(Math.abs(ballVel.x)<0.001) ballVel.x=0;
  if(Math.abs(ballVel.z)<0.001) ballVel.z=0;

  ballEl.setAttribute('position',pos);
  requestAnimationFrame(updateBall);
}
updateBall();

// Aim arrow
const aimArrow = document.querySelector('#aimArrow');
function updateAimArrow(){
  const pos = ballEl.getAttribute('position');
  const endX = pos.x + Math.sin(aimAngle)*2;
  const endZ = pos.z - Math.cos(aimAngle)*2;
  aimArrow.setAttribute('line',`start: ${pos.x} 0.5 ${pos.z}; end: ${endX} 0.5 ${endZ}; color: red`);
  requestAnimationFrame(updateAimArrow);
}
updateAimArrow();
</script>
</body>
</html>