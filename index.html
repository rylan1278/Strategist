<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini Golf Maze Course</title>
<script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
</head>
<body>
<a-scene>

  <!-- Sky and ground -->
  <a-sky color="#87CEEB"></a-sky>
  <a-plane color="#2d5016" rotation="-90 0 0" width="500" height="500"></a-plane>

  <!-- Ball -->
  <a-sphere id="ball" position="0 0.5 0" radius="0.2" color="#ffffff"></a-sphere>

  <!-- Camera -->
  <a-entity id="cameraRig" position="0 3 6">
    <a-camera id="camera"></a-camera>
  </a-entity>

  <!-- Aim arrow -->
  <a-entity id="aimArrow" line="start: 0 0.5 0; end: 0 0.5 -2; color: red"></a-entity>

</a-scene>

<script>
const scene = document.querySelector('a-scene');

// ---- Define the path as points ----
const path = [
  {x:0, z:0},
  {x:0, z:-20},
  {x:15, z:-40},
  {x:5, z:-60},
  {x:5, z:-80},
  {x:-10, z:-95},
  {x:10, z:-115},
  {x:8, z:-140},
  {x:8, z:-160}
];

const fairwayWidth = 4;
const wallColliders = []; // Store ONLY collision data here

// Helper to create a fairway segment and walls
function createSegment(start, end) {
  const dx = end.x - start.x;
  const dz = end.z - start.z;
  const length = Math.sqrt(dx*dx + dz*dz);
  const angle = Math.atan2(dx, dz);
  const angleDeg = angle * (180/Math.PI);

  const midX = (start.x + end.x) / 2;
  const midZ = (start.z + end.z) / 2;

  // Fairway
  const fairway = document.createElement('a-box');
  fairway.setAttribute('position', `${midX} 0.01 ${midZ}`);
  fairway.setAttribute('width', fairwayWidth);
  fairway.setAttribute('height', 0.02);
  fairway.setAttribute('depth', length);
  fairway.setAttribute('rotation', `0 ${angleDeg} 0`);
  fairway.setAttribute('color', '#3a7d44');
  scene.appendChild(fairway);

  // Direction vector along the wall
  const dirX = Math.sin(angle);
  const dirZ = -Math.cos(angle);
  
  // Perpendicular vector (for wall offset)
  const perpX = -dirZ;
  const perpZ = dirX;

  // Left wall
  const leftX = midX + perpX * (fairwayWidth/2);
  const leftZ = midZ + perpZ * (fairwayWidth/2);
  const leftWall = document.createElement('a-box');
  leftWall.setAttribute('position', `${leftX} 0.5 ${leftZ}`);
  leftWall.setAttribute('width', 0.2);
  leftWall.setAttribute('height', 1);
  leftWall.setAttribute('depth', length);
  leftWall.setAttribute('rotation', `0 ${angleDeg} 0`);
  leftWall.setAttribute('color', '#5c4033');
  scene.appendChild(leftWall);

  // Store left wall collision data as LINE SEGMENT
  wallColliders.push({
    x1: leftX - dirX * length/2,
    z1: leftZ - dirZ * length/2,
    x2: leftX + dirX * length/2,
    z2: leftZ + dirZ * length/2
  });

  // Right wall
  const rightX = midX - perpX * (fairwayWidth/2);
  const rightZ = midZ - perpZ * (fairwayWidth/2);
  const rightWall = document.createElement('a-box');
  rightWall.setAttribute('position', `${rightX} 0.5 ${rightZ}`);
  rightWall.setAttribute('width', 0.2);
  rightWall.setAttribute('height', 1);
  rightWall.setAttribute('depth', length);
  rightWall.setAttribute('rotation', `0 ${angleDeg} 0`);
  rightWall.setAttribute('color', '#5c4033');
  scene.appendChild(rightWall);

  // Store right wall collision data as LINE SEGMENT
  wallColliders.push({
    x1: rightX - dirX * length/2,
    z1: rightZ - dirZ * length/2,
    x2: rightX + dirX * length/2,
    z2: rightZ + dirZ * length/2
  });
}

// Build the course
for(let i=0;i<path.length-1;i++){
  createSegment(path[i], path[i+1]);
}

// ---- Obstacles ----
const obstacles = [];
function createObstacle(x,z,w=1,d=2){
  const ob = document.createElement('a-box');
  ob.setAttribute('position',`${x} 0.2 ${z}`);
  ob.setAttribute('width',w);
  ob.setAttribute('height',0.5);
  ob.setAttribute('depth',d);
  ob.setAttribute('color','#d62828');
  scene.appendChild(ob);
  obstacles.push({x:x,z:z,w:w,d:d});
}
createObstacle(0,-10,1,2);
createObstacle(10,-30,1.5,1.5);
createObstacle(7,-50,1,2);
createObstacle(5,-70,1.5,1);
createObstacle(-5,-88,1,2);
createObstacle(5,-105,1.5,1.5);
createObstacle(8,-130,1,2);

// ---- Hole ----
const hole = document.createElement('a-cylinder');
hole.setAttribute('position',`${path[path.length-1].x} 0 ${path[path.length-1].z}`);
hole.setAttribute('radius',0.3);
hole.setAttribute('height',0.1);
hole.setAttribute('color','#000');
scene.appendChild(hole);

const holeFlagPole = document.createElement('a-cylinder');
holeFlagPole.setAttribute('position',`${path[path.length-1].x} 0.8 ${path[path.length-1].z}`);
holeFlagPole.setAttribute('radius',0.03);
holeFlagPole.setAttribute('height',1.6);
holeFlagPole.setAttribute('color','#fff');
scene.appendChild(holeFlagPole);

const holeFlag = document.createElement('a-box');
holeFlag.setAttribute('position',`${path[path.length-1].x} 1.5 ${path[path.length-1].z}`);
holeFlag.setAttribute('width',0.5);
holeFlag.setAttribute('height',0.3);
holeFlag.setAttribute('depth',0.02);
holeFlag.setAttribute('color','#f00');
scene.appendChild(holeFlag);

// ---- Ball physics ----
const ballEl = document.querySelector('#ball');
let ballVel = {x:0,z:0};
let aimAngle = 0;

// Camera WASD
const cameraRig = document.querySelector('#cameraRig');
const camera = document.querySelector('#camera');
let orbitX=0,orbitZ=6,orbitHeight=3;
const keys={};
window.addEventListener('keydown', e=>keys[e.code]=true);
window.addEventListener('keyup', e=>keys[e.code]=false);

// Q/E aim, Space putt
window.addEventListener('keydown', e=>{
  if(e.code==='KeyQ') aimAngle-=0.05;
  if(e.code==='KeyE') aimAngle+=0.05;
  if(e.code==='Space'){
    const power=0.5;
    ballVel.x=Math.sin(aimAngle)*power;
    ballVel.z=-Math.cos(aimAngle)*power;
  }
});

// Camera
function updateCamera(){
  const pos = ballEl.getAttribute('position');
  if(keys['KeyW']) orbitZ-=0.5;
  if(keys['KeyS']) orbitZ+=0.5;
  if(keys['KeyA']) orbitX-=0.5;
  if(keys['KeyD']) orbitX+=0.5;

  cameraRig.setAttribute('position',{x:pos.x+orbitX,y:pos.y+orbitHeight,z:pos.z+orbitZ});
  camera.object3D.lookAt(new THREE.Vector3(pos.x,pos.y+0.5,pos.z));
  requestAnimationFrame(updateCamera);
}
updateCamera();

// Point to line segment distance and closest point
function closestPointOnSegment(px, pz, x1, z1, x2, z2) {
  const dx = x2 - x1;
  const dz = z2 - z1;
  const lenSq = dx*dx + dz*dz;
  
  if(lenSq === 0) return {x: x1, z: z1};
  
  let t = ((px - x1) * dx + (pz - z1) * dz) / lenSq;
  t = Math.max(0, Math.min(1, t));
  
  return {
    x: x1 + t * dx,
    z: z1 + t * dz
  };
}

// Ball movement
function updateBall(){
  const pos = ballEl.getAttribute('position');
  pos.x += ballVel.x;
  pos.z += ballVel.z;
  pos.y = 0.5;

  const ballRadius = 0.2;
  const wallThickness = 0.1;

  // Check ONLY wall colliders
  for(let wall of wallColliders){
    const closest = closestPointOnSegment(pos.x, pos.z, wall.x1, wall.z1, wall.x2, wall.z2);
    
    const dx = pos.x - closest.x;
    const dz = pos.z - closest.z;
    const dist = Math.sqrt(dx*dx + dz*dz);
    
    if(dist < ballRadius + wallThickness){
      // Reflect velocity
      const nx = dx / dist;
      const nz = dz / dist;
      
      const dot = ballVel.x * nx + ballVel.z * nz;
      if(dot < 0){
        ballVel.x -= 2 * dot * nx;
        ballVel.z -= 2 * dot * nz;
        ballVel.x *= 0.75;
        ballVel.z *= 0.75;
        
        // Push ball out
        const overlap = (ballRadius + wallThickness) - dist;
        pos.x += nx * overlap;
        pos.z += nz * overlap;
      }
    }
  }

  // Check obstacles
  for(let o of obstacles){
    const dx = pos.x - o.x;
    const dz = pos.z - o.z;
    
    const clampedX = Math.max(-o.w/2, Math.min(o.w/2, dx));
    const clampedZ = Math.max(-o.d/2, Math.min(o.d/2, dz));
    
    const closestX = o.x + clampedX;
    const closestZ = o.z + clampedZ;
    
    const distX = pos.x - closestX;
    const distZ = pos.z - closestZ;
    const dist = Math.sqrt(distX*distX + distZ*distZ);
    
    if(dist < ballRadius){
      const nx = distX / dist;
      const nz = distZ / dist;
      
      const dot = ballVel.x * nx + ballVel.z * nz;
      if(dot < 0){
        ballVel.x -= 2 * dot * nx;
        ballVel.z -= 2 * dot * nz;
        ballVel.x *= 0.75;
        ballVel.z *= 0.75;
        
        const overlap = ballRadius - dist;
        pos.x += nx * overlap;
        pos.z += nz * overlap;
      }
    }
  }

  // Friction
  ballVel.x *= 0.97;
  ballVel.z *= 0.97;
  if(Math.abs(ballVel.x)<0.001) ballVel.x=0;
  if(Math.abs(ballVel.z)<0.001) ballVel.z=0;

  ballEl.setAttribute('position',pos);
  requestAnimationFrame(updateBall);
}
updateBall();

// Aim arrow
const aimArrow = document.querySelector('#aimArrow');
function updateAimArrow(){
  const pos = ballEl.getAttribute('position');
  const endX = pos.x + Math.sin(aimAngle)*2;
  const endZ = pos.z - Math.cos(aimAngle)*2;
  aimArrow.setAttribute('line',`start: ${pos.x} 0.5 ${pos.z}; end: ${endX} 0.5 ${endZ}; color: red`);
  requestAnimationFrame(updateAimArrow);
}
updateAimArrow();
</script>
</body>
</html>