<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mini Golf Game</title>
  <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
</head>
<body>
<a-scene>

  <!-- Sky and ground -->
  <a-sky color="#87CEEB"></a-sky>
  <a-plane color="#228B22" rotation="-90 0 0" width="50" height="50"></a-plane>

  <!-- Golf ball -->
  <a-sphere id="ball" position="0 0.5 -5" radius="0.5" color="#ffffff"></a-sphere>

  <!-- Hole -->
  <a-cylinder id="hole" position="0 0 -15" radius="0.7" height="0.1" color="#000000"></a-cylinder>

  <!-- Camera rig -->
  <a-entity id="cameraRig" position="0 3 6">
    <a-camera id="camera"></a-camera>
  </a-entity>

  <!-- Aim line -->
  <a-entity id="aimLine" line="start: 0 0 0; end: 0 0 0; color: red"></a-entity>

</a-scene>

<script>
const ball = document.querySelector("#ball");
const camera = document.querySelector("#camera");
const cameraRig = document.querySelector("#cameraRig");
const aimLine = document.querySelector("#aimLine");

let ballVel = {x:0, z:0};

// Camera rotation control
let rotateAngle = 0;
let isDragging = false;
let lastX = 0;

window.addEventListener("mousedown", e => {
  isDragging = true;
  lastX = e.clientX;
});

window.addEventListener("mouseup", e => isDragging = false);
window.addEventListener("mousemove", e => {
  if (!isDragging) return;
  const dx = e.clientX - lastX;
  rotateAngle += dx * 0.005; // rotation speed
  lastX = e.clientX;
});

// Click-to-putt
window.addEventListener("click", e => {
  const pos = ball.getAttribute("position");

  // Use rotateAngle for forward direction
  const forward = {x: Math.sin(rotateAngle), z: -Math.cos(rotateAngle)};
  const power = 0.2;
  ballVel.x = forward.x * power;
  ballVel.z = forward.z * power;

  // Temporary aim line
  aimLine.setAttribute("line", `start: ${pos.x} ${pos.y} ${pos.z}; end: ${pos.x + forward.x*2} ${pos.y} ${pos.z + forward.z*2}; color: red`);
  setTimeout(() => {
    aimLine.setAttribute("line", "start: 0 0 0; end: 0 0 0; color: red");
  }, 200);
});

// Update ball
function updateBall() {
  const pos = ball.getAttribute("position");
  pos.x += ballVel.x;
  pos.z += ballVel.z;
  pos.y = 0.5;
  ball.setAttribute("position", pos);

  // Damping
  ballVel.x *= 0.95;
  ballVel.z *= 0.95;
  if (Math.abs(ballVel.x) < 0.001) ballVel.x = 0;
  if (Math.abs(ballVel.z) < 0.001) ballVel.z = 0;

  requestAnimationFrame(updateBall);
}
updateBall();

// Camera follow behind ball
function followBall() {
  const pos = ball.getAttribute("position");
  const camDistance = 6;
  const camHeight = 3;

  // Compute behind vector from rotateAngle
  const offsetX = Math.sin(rotateAngle) * -camDistance;
  const offsetZ = Math.cos(rotateAngle) * camDistance;

  cameraRig.setAttribute("position", {
    x: pos.x + offsetX,
    y: pos.y + camHeight,
    z: pos.z + offsetZ
  });

  camera.object3D.lookAt(new THREE.Vector3(pos.x, pos.y + 0.5, pos.z));

  requestAnimationFrame(followBall);
}
followBall();
</script>
</body>
</html>
